#pragma once
#include <string>

static const std::string VERT_GLSL =
"layout (location = 0) in vec3 aPosition;"
"layout (location = 1) in vec3 aNormal;"
"layout (location = 2) in vec2 aTexCoords;"
"layout (location = 3) in vec3 aTangent;"
"out VS_OUT {"
"vec3 FragPos;"
"vec2 TexCoords;"
"mat3 TBN;"
"} vs_out;"
"uniform mat4 model;"
"uniform mat4 view;"
"uniform mat4 projection;"
"uniform mat4 normal;"
"void main()"
"{"
"gl_Position = projection * view * model * vec4(aPosition, 1.0f);"
"vs_out.FragPos = vec3(model * vec4(aPosition, 1.0));"
"vs_out.TexCoords = aTexCoords;"
"vec3 T = normalize(vec3(normal * vec4(aTangent, 0.0)));"
"vec3 N = normalize(vec3(normal * vec4(aNormal, 0.0)));"
"T = normalize(T - dot(T, N) * N); "
"vec3 B = cross(T, N);"
"vs_out.TBN = mat3(T, B, N);"
"}";

static const std::string FRAG_GLSL =
"out vec4 FragColor;"
"in VS_OUT {"
"vec3 FragPos;"
"vec2 TexCoords;"
"mat3 TBN;"
"} fs_in;"
"struct Material {"
"sampler2D diffuse1;"
"sampler2D normal1;"
"float shininess;"
"};"
"struct DirLight {"
"vec3 direction;"
"vec3 ambient;"
"vec3 diffuse;"
"vec3 specular;"
"};"
"struct PointLight {"
"vec3 position;"
"float constant;"
"float linear;"
"float quadratic;"
"vec3 ambient;"
"vec3 diffuse;"
"vec3 specular;"
"};"
"uniform Material material;"
"uniform bool normalMapping;"
"uniform vec3 viewPos;"
"uniform DirLight dirLight;"
"uniform PointLight pointLights[4];"
"vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir, vec2 texCoords);"
"vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir, vec2 texCoords);"
"void main()"
"{"
"vec3 normal = texture(material.normal1, fs_in.TexCoords).rgb;"
"normal = normalize(normal * 2.0 - 1.0);"
"normal = normalize(fs_in.TBN * normal); "
"vec3 viewDir = normalize(viewPos - fs_in.FragPos);"
"vec3 result = vec3(0.0, 0.0, 0.0);"
"result += CalcDirLight(dirLight, normal, viewDir, fs_in.TexCoords);"
"for(int i = 0; i < 4; i++)"
"result += CalcPointLight(pointLights[i], normal, fs_in.FragPos, viewDir, fs_in.TexCoords);"
"FragColor = vec4(result, 1.0);"
"}"
"vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir, vec2 texCoords)"
"{"
"vec3 lightDir = normalize(-light.direction);"
"float diff = max(dot(normal, lightDir), 0.0);"
"vec3 reflectDir = reflect(-lightDir, normal);"
"float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);"
"vec3 ambient = light.ambient * vec3(texture(material.diffuse1, texCoords));"
"vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse1, texCoords));"
"vec3 specular = light.specular * spec; "
"return (ambient + diffuse + specular);"
"}"
"vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir, vec2 texCoords)"
"{"
"vec3 lightDir = normalize(light.position - fragPos);"
"float diff = max(dot(normal, lightDir), 0.0);"
"vec3 reflectDir = reflect(-lightDir, normal);"
"float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);"
"float distance = length(light.position - fragPos);"
"float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));"
"vec3 ambient = light.ambient * vec3(texture(material.diffuse1, texCoords));"
"vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse1, texCoords));"
"vec3 specular = light.specular * spec; "
"ambient *= attenuation;"
"diffuse *= attenuation;"
"specular *= attenuation;"
"return (ambient + diffuse + specular);"
"}";
